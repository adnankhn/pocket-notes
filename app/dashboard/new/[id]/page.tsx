import { SubmitButton } from "@/app/components/Submitbuttons";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import Link from "next/link";
import prisma from "@/app/lib/db";
import { getKindeServerSession } from "@kinde-oss/kinde-auth-nextjs/server";
import { redirect } from "next/navigation";
import { revalidatePath, unstable_noStore as noStore } from "next/cache";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

const { GoogleGenerativeAI } = require("@google/generative-ai");
import { HarmBlockThreshold, HarmCategory } from "@google/generative-ai";

import ReactMarkdown from 'react-markdown';
import { ExternalLink } from "lucide-react";



const safetySettings = [
  {
    category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
    threshold: HarmBlockThreshold.BLOCK_NONE,
  },
];


const genAI = new GoogleGenerativeAI(process.env.API_KEY);

async function run() {
  
  
}




async function generateArticleSummary(data: string): Promise<string> {
  "use server"
  try {
    console.log("Outside");
    console.log(data?.description);
    if (data?.description) {
      
      console.log("Inside");
      console.log(data?.description);
      return data.description;
    } else {
      
      
      
      
      
      const model = genAI.getGenerativeModel({ model: "gemini-pro", safetySettings});
      console.log("Summary generated by gemini");
      
      
      const prompt = `write a short summary of this article and return the output only in markdown format: ${data?.jsonData.content}`
      
  
      const result = await model.generateContent(prompt);
      const response = await result.response;
      console.log(response);
      const text = response.text();
      console.log(text);

      
      const existingNote = await prisma.note.findUnique({
        where: {
          id: data?.id,
        },
      });

      
      if ((text) && (existingNote?.description === null)) {
        await prisma.note.update({
          where: {
            id: data?.id,
          },
          data: {
            description: text,
          },
        });
      }

      return text;
    }
  } catch (error) {
    console.error("Error generating article summary:", error);
    
    return "Failed to generate article summary";
  }
}


async function getData({ userId, noteId }: { userId: string; noteId: string }) {
  noStore();
  const data = await prisma.note.findUnique({
    where: {
      id: noteId,
      userId: userId,
    },
    select: {
      title: true,
      description: true,
      id: true,
      jsonData: true,
      url: true,
    },
  });

  return data;
}
const cachedSummaries = new Map<string, string>();
const generationInProgress = new Map<string, Promise<string>>();


export default async function DynamicRoute({
  params,
}: {
  params: { id: string };
}) {
  const { getUser } = getKindeServerSession();
  const user = await getUser();
  const data = await getData({ userId: user?.id as string, noteId: params.id });
  

  
  let summary = cachedSummaries.get(data.id);
  if (!summary) {
    
    let generationPromise = generationInProgress.get(data.id);
    if (!generationPromise) {
      
      generationPromise = generateAndCacheSummary(data);
      generationInProgress.set(data.id, generationPromise);
    }
    
    summary = await generationPromise;
  }

  async function generateAndCacheSummary(data) {
    try {
      console.log(`Generating summary for note ID: ${data.id}`);
      const summary = await generateArticleSummary(data);
      console.log(`Summary generated for note ID: ${data.id}`);
      cachedSummaries.set(data.id, summary); 
      return summary;
    } finally {
      
      generationInProgress.delete(data.id);
      console.log(`Generation completed for note ID: ${data.id}`);
    }
  }
  
  async function postData(formData: FormData) {
    "use server";

    if (!user) throw new Error("you are not allowed");

    const title = formData.get("title") as string;
    const description = formData.get("description") as string;

    await prisma.note.update({
      where: {
        id: data?.id,
        userId: user.id,
      },
      data: {
        description: description,
        title: title,
      },
    });

    revalidatePath("/dashboard");

    return redirect("/dashboard");  
  }
  
  return (
    <Card>
      <form action={postData}>
        <CardHeader>
          <CardTitle>View Article</CardTitle>
        </CardHeader>
        <CardContent className="flex flex-col gap-y-5">
          <div className="gap-y-2 flex flex-col">
            <Label>Title</Label>
            <Input
              required
              type="text"
              name="title"
              placeholder="Title for your note"
              defaultValue={data?.title}
            />
          </div>

<div className="flex flex-col gap-y-2">
  <Label htmlFor="url">URL</Label>
  <div className="flex items-center gap-x-2">
    {data?.url && (
      <a href={data.url} target="_blank" rel="noopener noreferrer" className="flex items-center gap-x-1 text-primary hover:underline">
        <span>Visit Page</span>
        <ExternalLink size={20} />
      </a>
    )}
  </div>
</div>



          <Tabs defaultValue="account">
            <TabsList>
              <TabsTrigger value="account">Original</TabsTrigger>
              <TabsTrigger value="summary">AI Summary</TabsTrigger>
            </TabsList>
            <TabsContent value="account">
              {data?.jsonData && (
                <div className="article-content">
                  <h1>Title: {data?.jsonData.title}</h1>
                  <p>Byline: {data?.jsonData.byline}</p>
                  <div
                    className="prose lg:prose-base dark:prose-invert max-w-[800px] mx-auto prose-hr:hidden"
                    dangerouslySetInnerHTML={{ __html: data?.jsonData.content }}
                  />
                </div>
              )}
            </TabsContent>
            <TabsContent value="summary">
              {data?.jsonData && (
                  <article className="prose lg:prose-base dark:prose-invert max-w-[800px] mx-auto prose-hr:hidden">
                  <ReactMarkdown>{summary}</ReactMarkdown>
                 </article>
              )}
            </TabsContent>
          </Tabs>
        </CardContent>

        <CardFooter className="flex justify-between">
          <Button asChild variant="secondary">
            <Link href="/dashboard">Back</Link>
          </Button>
          {/* <SubmitButton /> */}
        </CardFooter>
      </form>
    </Card>
  );
}
